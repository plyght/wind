use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;
use wind_core::{
    ChosenSide, Conflict, ConflictType, Manifest, MergeEngine, MergeResult, NodeID, ObjectStore,
    Permissions, OID,
};

struct MockObjectStore {
    contents: HashMap<OID, Vec<u8>>,
}

impl MockObjectStore {
    fn new() -> Self {
        Self {
            contents: HashMap::new(),
        }
    }

    fn add_content(&mut self, content: &[u8]) -> OID {
        let mut hasher = [0u8; 32];
        hasher[..content.len().min(32)].copy_from_slice(&content[..content.len().min(32)]);
        let oid = OID::from_bytes(hasher);
        self.contents.insert(oid, content.to_vec());
        oid
    }
}

impl ObjectStore for MockObjectStore {
    fn read_content(&self, oid: &OID) -> anyhow::Result<Vec<u8>> {
        self.contents
            .get(oid)
            .cloned()
            .ok_or_else(|| anyhow::anyhow!("Content not found"))
    }

    fn write_content(&self, content: &[u8]) -> anyhow::Result<OID> {
        let mut hasher = [0u8; 32];
        hasher[..content.len().min(32)].copy_from_slice(&content[..content.len().min(32)]);
        Ok(OID::from_bytes(hasher))
    }

    fn read_manifest(&self, _oid: &OID) -> anyhow::Result<Manifest> {
        Ok(Manifest::new())
    }
}

#[test]
fn test_merge_no_conflict() {
    let mut store = MockObjectStore::new();

    let base_oid = store.add_content(b"base content");
    let left_oid = store.add_content(b"left content");
    let right_oid = store.add_content(b"base content");

    let node_id = NodeID::new();

    let mut base = Manifest::new();
    base.insert(
        PathBuf::from("file.txt"),
        node_id,
        base_oid,
        Permissions::REGULAR,
    );

    let mut left = Manifest::new();
    left.insert(
        PathBuf::from("file.txt"),
        node_id,
        left_oid,
        Permissions::REGULAR,
    );

    let mut right = Manifest::new();
    right.insert(
        PathBuf::from("file.txt"),
        node_id,
        right_oid,
        Permissions::REGULAR,
    );

    let engine = MergeEngine::new(Arc::new(store));
    let result = engine.merge(&base, &left, &right).unwrap();

    assert!(result.success);
    assert_eq!(result.conflicts.len(), 0);
}

#[test]
fn test_merge_move_conflict() {
    let mut store = MockObjectStore::new();

    let base_oid = store.add_content(b"content");

    let node_id = NodeID::new();

    let mut base = Manifest::new();
    base.insert(
        PathBuf::from("file.txt"),
        node_id,
        base_oid,
        Permissions::REGULAR,
    );

    let mut left = Manifest::new();
    left.insert(
        PathBuf::from("left_file.txt"),
        node_id,
        base_oid,
        Permissions::REGULAR,
    );

    let mut right = Manifest::new();
    right.insert(
        PathBuf::from("right_file.txt"),
        node_id,
        base_oid,
        Permissions::REGULAR,
    );

    let engine = MergeEngine::new(Arc::new(store));
    let result = engine.merge(&base, &left, &right).unwrap();

    assert!(!result.success);
    assert_eq!(result.conflicts.len(), 1);

    let conflict = &result.conflicts[0];
    assert_eq!(conflict.node_id, node_id);
    assert!(matches!(conflict.conflict_type, ConflictType::MoveConflict));
}

#[test]
fn test_merge_delete_modify_conflict() {
    let mut store = MockObjectStore::new();

    let base_oid = store.add_content(b"base");
    let right_oid = store.add_content(b"modified");

    let node_id = NodeID::new();

    let mut base = Manifest::new();
    base.insert(
        PathBuf::from("file.txt"),
        node_id,
        base_oid,
        Permissions::REGULAR,
    );

    let left = Manifest::new();

    let mut right = Manifest::new();
    right.insert(
        PathBuf::from("file.txt"),
        node_id,
        right_oid,
        Permissions::REGULAR,
    );

    let engine = MergeEngine::new(Arc::new(store));
    let result = engine.merge(&base, &left, &right).unwrap();

    assert!(!result.success);
    assert_eq!(result.conflicts.len(), 1);

    let conflict = &result.conflicts[0];
    assert!(matches!(conflict.conflict_type, ConflictType::DeleteModify));
}

#[test]
fn test_merge_add_add_same() {
    let mut store = MockObjectStore::new();

    let oid = store.add_content(b"same content");
    let node_id = NodeID::new();

    let base = Manifest::new();

    let mut left = Manifest::new();
    left.insert(
        PathBuf::from("file.txt"),
        node_id,
        oid,
        Permissions::REGULAR,
    );

    let mut right = Manifest::new();
    right.insert(
        PathBuf::from("file.txt"),
        node_id,
        oid,
        Permissions::REGULAR,
    );

    let engine = MergeEngine::new(Arc::new(store));
    let result = engine.merge(&base, &left, &right).unwrap();

    assert!(result.success);
    assert_eq!(result.conflicts.len(), 0);
}

#[test]
fn test_merge_add_add_conflict() {
    let mut store = MockObjectStore::new();

    let left_oid = store.add_content(b"left content");
    let right_oid = store.add_content(b"right content");
    let node_id = NodeID::new();

    let base = Manifest::new();

    let mut left = Manifest::new();
    left.insert(
        PathBuf::from("file.txt"),
        node_id,
        left_oid,
        Permissions::REGULAR,
    );

    let mut right = Manifest::new();
    right.insert(
        PathBuf::from("file.txt"),
        node_id,
        right_oid,
        Permissions::REGULAR,
    );

    let engine = MergeEngine::new(Arc::new(store));
    let result = engine.merge(&base, &left, &right).unwrap();

    assert!(!result.success);
    assert_eq!(result.conflicts.len(), 1);

    let conflict = &result.conflicts[0];
    assert!(matches!(conflict.conflict_type, ConflictType::AddAdd));
}

#[test]
fn test_apply_resolution() {
    let mut store = MockObjectStore::new();

    let left_oid = store.add_content(b"left content");
    let right_oid = store.add_content(b"right content");

    let node_id = NodeID::new();

    let conflict = Conflict {
        node_id,
        conflict_type: ConflictType::ContentConflict,
        base_content: None,
        left_content: Some(left_oid),
        right_content: Some(right_oid),
        base_path: None,
        left_path: Some(PathBuf::from("file.txt")),
        right_path: Some(PathBuf::from("file.txt")),
    };

    let engine = MergeEngine::new(Arc::new(store));

    let choice = engine
        .apply_resolution(&conflict, ChosenSide::Left, None)
        .unwrap();

    assert_eq!(choice.node_id, node_id);
    assert_eq!(choice.final_oid, left_oid);
    assert!(!choice.manual_edit);
}
